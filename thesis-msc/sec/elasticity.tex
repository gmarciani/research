\chapter{Smart Elasticity}
\label{chp:smart-elasticity}


% %
% HEADER
% %
\lipsum[1]


% %
% RESOURCE MANAGEMENT
% %
\section{Resource Management}
\label{sec:containers-orchestration-resource-management}

\lipsum[1]


% %
% CONTAINERIZATION
% %
\section{Containerization}
\label{sec:containers-orchestration-containerization}

With modern web services, users expect applications to be available 24/7, and developers expect to deploy new versions of those applications several times a day. Containerization helps package software to serve these goals, enabling applications to be released and updated in an easy and fast way without downtime.

The Old Way to deploy applications was to install the applications on a host using the operating system package manager. This had the disadvantage of entangling the applications’ executables, configuration, libraries, and lifecycles with each other and with the host OS. One could build immutable virtual-machine images in order to achieve predictable rollouts and rollbacks, but VMs are heavyweight and non-portable.

The New Way is to deploy containers based on operating-system-level virtualization rather than hardware virtualization. These containers are isolated from each other and from the host: they have their own filesystems, they can’t see each others’ processes, and their computational resource usage can be bounded. They are easier to build than VMs, and because they are decoupled from the underlying infrastructure and from the host filesystem, they are portable across clouds and OS distributions.

Because containers are small and fast, one application can be packed in each container image. This one-to-one application-to-image relationship unlocks the full benefits of containers. With containers, immutable container images can be created at build/release time rather than deployment time, since each application doesn’t need to be composed with the rest of the application stack, nor married to the production infrastructure environment. Generating container images at build/release time enables a consistent environment to be carried from development into production. Similarly, containers are vastly more transparent than VMs, which facilitates monitoring and management. This is especially true when the containers’ process lifecycles are managed by the infrastructure rather than hidden by a process supervisor inside the container. Finally, with a single application per container, managing the containers becomes tantamount to managing deployment of the application.

Summary of container benefits:

Agile application creation and deployment: Increased ease and efficiency of container image creation compared to VM image use.
Continuous development, integration, and deployment: Provides for reliable and frequent container image build and deployment with quick and easy rollbacks (due to image immutability).
Dev and Ops separation of concerns: Create application container images at build/release time rather than deployment time, thereby decoupling applications from infrastructure.
Environmental consistency across development, testing, and production: Runs the same on a laptop as it does in the cloud.
Cloud and OS distribution portability: Runs on Ubuntu, RHEL, CoreOS, on-prem, Google Kubernetes Engine, and anywhere else.
Application-centric management: Raises the level of abstraction from running an OS on virtual hardware to run an application on an OS using logical resources.
Loosely coupled, distributed, elastic, liberated micro-services: Applications are broken into smaller, independent pieces and can be deployed and managed dynamically – not a fat monolithic stack running on one big single-purpose machine.
Resource isolation: Predictable application performance.
Resource utilization: High efficiency and density.

To make use of this new model of deployment, applications need to be packaged in a way that decouples them from individual hosts: they need to be containerized.

Containerized applications are more flexible and available than in past deployment models, where applications were installed directly onto specific machines packages deeply integrated into the host.


% %
% MICRO-SERVICE ARCHITECTURE
% %
\section{Micro-service Architecture}
\label{sec:containers-orchestration-micro-service-architecture}

A software component that is independently deployable and scalable.



% %
% ELASTICITY
% %
\section{Elasticity}
\label{sec:containers-orchestration-elasticity}

\lipsum[1]

% %
% ELASTICITY
% %
\section{Elasticity}
\label{sec:containers-orchestration-elasticity}
Describe the concept of elasticity, how it has been addressed in literature and how it is applied in modern software solutions.


% %
% PLACEMENT
% %
\section{Placement}
\label{sec:containers-orchestration-elasticity}
Describe the concept of placement and how it has been addressed in literature and how it is applied in modern software solutions.