\section{Implementation}
\label{sec:implementation}

The bot has been realized as a Maven-based\footnote{it follows the structure of the basic quickstart archetype.} Java\footnote{Oracle Java 1.8} desktop application, packaged into a self-contained\footnote{fat jar encapsulating all external dependencies.} jar with shrunk and obfuscated code (\Cref{sec:concealment}).

Basically, the bot implements the finite state automaton (\Cref{sec:bot}) and the functionalities required for configuration parsing (\Cref{sec:configuration}), commands execution (\Cref{sec:commands}) and logging (\Cref{sec:logging}). All functionalities has been tested carefully against 123 total JUnit tests.

\textcolor{green}{WEB INTERFACE IMPLEMENTATION \lipsum[1]}

Our bot and web user interfaces leverage some of well known technologies. Here we present them, giving an idea about how they have been used in our implementation. The reader may refer to the open source code of the project and the corresponding Javadocs to get into implementation details.

\begin{description}
  \setlength\itemsep{1em}

  \item[QUARTZ] job scheduling framework developed by the Terracotta Inc \cite{quartz-scheduler}.
  It is a widely adopted solution to support process workflow and system management in enterprise applications.
  In our application it is used for the scheduling of attacks and the sleep mode.

  \item[LOG4J2] logging framework developed by the Apache Software Foundation \cite{log4j2}.
  Together with its main competitor, Logback, it is a de facto standard for logging in Java. Tipically it is used as a bunding of SLF4J, that is a widely adopted logging facade.
  In our application, it is used both for console and file logging.

  \item[COMMONS CLI] command line parsing framework developed by the Apache Software Foundation as a part of the bigger Jakarta project\cite{commons-cli}.
  It is a well known solution for argument parsing in CLI based Java applications.

  \item[JACKSON] serialization framework developed by the Fasterxml team \cite{jackson,fasterxml}.
  It supports most of the widespread serialization format, such as JSON, XML, YAML and so on.
  In our application it is used to serialize/deserialize configuration (in YAML) and commands (in JSON).

  \item[LOMBOK] framework of annotations encapsulating boilerplates and simple patterns \cite{lombok}.
  In our application it is used to generate constructors getters/setters toString/hashCode methods. As such a generation is evaluated at compile time, the code of entity classes is considerably reduced.

  \item[BOOTSTRAP] \textcolor{green}{\lipsum[1]}

  \item[JQUERY] \textcolor{green}{\lipsum[1]}

\end{description}


\subsection{Concealment}
\label{sec:concealment}

Since the bot is a malicious software, his first priority is not to be discovered by the victim's system. Just like any malware, bots should be easily distributed, act covertly and evade the health checks of the infected system. Such a concealment can be achieved, in the first instance, by making the code \textit{minimal, efficient and obfuscated}.

Code minimization allows to distribute the bot in a small sized package, which is easy to conceal in an infection vector, easy to trasmit and whose installation on the system goes unnoticed.
Code efficiency allows the bot to act in a minimally invasive way in terms of memory usage, access to local resources, external communications and sub-processes creation.
Code obfuscation allows the bot to evade traditional health checks based on code patterns analysis. As a beneficial side effect, an obfuscation dictionary with short words can assist code minimization.

All of these aspects concerning the bot concealment have been implemented leveraging \textit{Proguard}, an utility for Java bytecode shrinking, optimization and obfuscation developed by the GuardSquare Inc. \cite{proguard}. ProGuard is the most popular optimizer for Java bytecode. It can make Java applications up to 90\% smaller, up to 20\% faster and protected against reverse engineering\cite{guardsquare}. Such great results makes it a widespread solution in the

In our application, Proguard has been embedded into the Maven packaging life-cycle via an ad-hoc plugin \cite{proguard-maven-plugin}. The adopted configuration of Proguard behaviour can be found in \texttt{config.pro}. From the configuration you may notice a conservative approach. The widespread use of reflection, serialization and annotations in the framework the bot code depends on, makes it necessary to limit both the shrinking and the obfuscation of these frameworks. A deeper code inspection on these frameworks would allow a more aggressive approach, thus obtaining a more minimized and obfuscated code. \footnote{Code obfuscation is subjected to a crucial tradeoff, because the excessive or naive code obfuscation may have collateral side effects. The obfuscation of the whole legitimate code may arouse suspicion of a meticolous checks, because only a legitimate program of high industrial value has no dependency on legitimate clear code. On the other hand, legitimate code letting guess actions of malicious program should never left clear.}.


\subsection{Logging}
\label{sec:logging}

Our bot logs both on console and file adopting a logging discipline that depends on the chosen execution mode.
Console logging prints events on the standard output\footnote{standard error is never used, neither in case of warnings nor errors.}.
File logging deals with two types of events: it appends received commands in \texttt{data/logs/commands.log} and attacks in \texttt{data/logs/attacks.log}. These two files are emptied every time the bot is started.

A general console log message has the following pattern

\begin{verbatim}
  [timestamp] [tread-name] [log-level] [class] [method] - [message]
\end{verbatim}

A file log message about commands has the following pattern

\begin{verbatim}
  [timestamp] Received [COMMAND] with [PARAMS] from CC at [CC-RESOURCE]
\end{verbatim}

A file log message about attacks has the following pattern

\begin{verbatim}
  [timestamp] Launching HTTP attack: [HTTP-METHOD] {TARGET} ([ITER]/[ITERS])
              with proxy [ADDR:PORT] and [HTTP-REQUEST-PROPS]
\end{verbatim}


The \texttt{default} mode prints in console the strictly relevant output and produces log files. The \texttt{trace} mode prints in console a detailed tracing output and produces log files. The \texttt{silent} mode does neither print anything in console nor produce any log file.
To run the program in one of these modes, specify the corresponding option, as indicated in \Cref{sec:helper}.
